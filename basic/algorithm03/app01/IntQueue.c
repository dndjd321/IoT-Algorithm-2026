// IntQueue 구현 파일

#include <stdio.h>
#include <stdlib.h>
#include "IntQueue.h"

/*====== 큐 초기화 ======*/
// parameter( IntQueue &(주소), 최대크기 )
// return -1(오류) 0(성공)
int Initialize(IntQueue* qu, int max) {

	qu->num = qu->front = qu->rear = 0;

	// 동적배열할당 오류 체크
	if ((qu->que = calloc(max, sizeof(int))) == NULL) {
		qu->max = 0;
		return -1;
	}

	qu->max = max;
	return 0;
}


/*====== 큐에 데이터 인큐 ======*/
// parameter( IntQueue &(주소), 들어갈 값 )
// return -1(오류) 0(성공)
int Enque(IntQueue* qu, int x) {

	// 큐가 가득 차 있는지 체크
	if (qu->num >= qu->max) {
		return -1;
	}
	else {
		qu->num++;	// 데이터 1건 증가
		qu->que[qu->rear] = x;	// 큐 마지막에 x 추가
		qu->rear++;		// rear 1 증가

		if (qu->rear == qu->max) {
			// 큐의 rear가 배열의 마지막까지 다 찼을 경우
			qu->rear = 0;
		}

		return 0;
	}
}

/*====== 큐에 데이터 디큐 ======*/
// parameter( IntQueue &(주소), 디큐로 가져올 값 )
// return -1(오류) 0(성공)
int Deque(IntQueue* qu, int* x) {
	if (qu->num <= 0) {
		return -1;
	}
	else {
		// 큐에서 데이터가 하나씩 빠지기에 num도 1씩 감소
		qu->num--;
		*x = qu->que[qu->front];
		qu->front++;

		// Deque를 계속 진행해서 배열 마지막까지 도달했을 경우
		if (qu->front == qu->max) {
			qu->front = 0;
		}

		return 0;
	}
}


/*====== 큐에서 데이터 피크 ======*/
// parameter( const IntQueue &(주소) 변경불가 , 확인할 값 )
// return -1(오류) 0(성공)
int Peek(const IntQueue* qu, int* x) {
	
	if (qu->num <= 0) {
		return -1;
	}

	*x = qu->que[qu->front];
	return 0;
}

/*====== 큐 클리어 ======*/
// parameter ( 전부 삭제할 큐 )
void Clear(IntQueue* qu) {
	qu->num = qu->front = qu->rear = 0;
}

/*====== 큐 최대 용량 ======*/
// parameter( 확인할 큐 )
// return 0~max
int Capacity(const IntQueue* qu) {
	return qu->max;
}

/*====== 큐에 저장된 데이터 수 ======*/
// parameter( 확인할 큐 )
// return 0~num
int Size(const IntQueue* qu) {
	return qu->num;
}

/*====== 큐가 비어있는지 체크 ======*/
// parameter( 확인할 큐 )
// return -1(오류) 0
int IsEmpty(const IntQueue* qu) {
	return qu->num <= 0;
}

/*====== 큐가 가득 찼는지 체크 ======*/
// parameter( 확인할 큐 )
// return -1(오류) 0
int IsFull(const IntQueue* qu) {
	return qu->num >= 0;
}

/*====== 큐 검색 ======*/
// parameter( 확인할 큐, 검색 위치 )
// return -1(오류) idx
int Search(const IntQueue* qu, int x) {
	for (int i = 0; i < qu->num; i++) {
		int idx = (qu->front + i) % qu->max;

		if (qu->que[idx] == x) {
			return idx;
		}
	}

	return -1;
}

/*====== 큐 출력 ======*/
// parameter( 확인할 큐 )
void Print(const IntQueue* qu) {
	for (int i = 0; i < qu->num; i++) {
		// (qu->front + i) % qu->max : rear가 front 보다 작을 수 있음
		printf("%d ", qu->que[(qu->front + i) % qu->max]);
	}
	printf("\n");
}

/*====== 큐 종료 ======*/
// parameter( 확인할 큐 )
void Terminate(IntQueue* qu) {
	if (qu->que != NULL) {
		free(qu->que);
	}
	qu->max = qu->num = qu->front = qu->rear = 0;
}